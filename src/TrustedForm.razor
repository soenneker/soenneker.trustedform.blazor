@using System.Threading
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@using Soenneker.Blazor.Extensions.EventCallback
@using Soenneker.Extensions.CancellationTokens
@using Soenneker.Extensions.ValueTask
@using Soenneker.TrustedForm.Blazor.Abstract
@using Soenneker.TrustedForm.Blazor.Options

@inject ITrustedFormInterop TrustedFormInterop

@inherits Soenneker.Quark.Components.Core.Cancellable.CoreCancellableElement
@implements ITrustedForm

<div id="@Id" @attributes="Attributes">
    @if (Configuration.IncludeForm)
    {
        <EditForm EditContext="@_ctx" OnSubmit="OnSubmit" id="@(Id + "-form")">
            @ChildContent
            <button id="@(Id + "-submit")" type="submit" style="display:none"></button>
        </EditForm>
    }
    else
    {
        @ChildContent
    }
</div>

@code {
    private DotNetObjectReference<TrustedForm>? _dotNetReference;

    private readonly string _elementGuid;

    private bool _initialized;
    private bool _isCreated;
    
    private readonly EditContext _ctx = new(new object());
    private static Task OnSubmit() => Task.CompletedTask;

    [Parameter]
    public EventCallback OnLoad { get; set; }

    [Parameter]
    public TrustedFormConfiguration Configuration { get; set; } = new();

    // Allow rendering to ensure child components can update their state
    protected override bool ShouldRender() => true;

    protected override void OnInitialized() => _dotNetReference = DotNetObjectReference.Create(this);

    public TrustedForm()
    {
        _elementGuid = Guid.NewGuid().ToString();
        Id = $"trustedform-{_elementGuid}";
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_isCreated)
        {
            Configuration.Field ??= $"trustedform-field-{_elementGuid}";

            await Create(CancellationToken).NoSync();
        }
    }

    private async ValueTask Create(CancellationToken cancellationToken)
    {
        if (_initialized)
            return;

        _initialized = true;

        await TrustedFormInterop.Init(Id!, Configuration, _dotNetReference!, cancellationToken).NoSync();
        await TrustedFormInterop.CreateObserver(Id!, cancellationToken).NoSync();

        _isCreated = true;
    }

    public async ValueTask<string?> GetCertUrl(CancellationToken cancellationToken = default)
    {
        CancellationToken linked = CancellationToken.Link(cancellationToken, out CancellationTokenSource? cts);

        using (cts)
            return await TrustedFormInterop.GetCertUrl(Id!, linked).NoSync();
    }

    public async ValueTask Stop(CancellationToken cancellationToken = default)
    {
        CancellationToken linked = CancellationToken.Link(cancellationToken, out CancellationTokenSource? cts);

        using (cts)
            await TrustedFormInterop.Stop(linked).NoSync();
    }

    public async ValueTask Start(CancellationToken cancellationToken = default)
    {
        CancellationToken linked = CancellationToken.Link(cancellationToken, out CancellationTokenSource? cts);

        using (cts)
            await TrustedFormInterop.Start(linked).NoSync();
    }

    public async ValueTask StartIfNotRunning(CancellationToken cancellationToken = default)
    {
        CancellationToken linked = CancellationToken.Link(cancellationToken, out CancellationTokenSource? cts);

        using (cts)
            await TrustedFormInterop.StartIfNotRunning(linked).NoSync();
    }

    public bool IsRecording()
    {
        return TrustedFormInterop.IsRecording();
    }

    public async ValueTask Finalize(CancellationToken cancellationToken = default)
    {
        CancellationToken linked = CancellationToken.Link(cancellationToken, out CancellationTokenSource? cts);

        using (cts)
        {
            await TrustedFormInterop.Finalize(Id!, Configuration, linked).NoSync();
        }
    }

    [JSInvokable]
    public Task OnLoadCallback()
    {
        return OnLoad.InvokeIfHasDelegate();
    }

    public override async ValueTask DisposeAsync()
    {
        await base.DisposeAsync().NoSync();

        _initialized = false;
        _isCreated = false;

        _dotNetReference?.Dispose();
    }

}